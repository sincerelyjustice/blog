{"blogs":[{"title":"References","path":"references","tags":["meta"],"timestamp":1698176900208,"content":"I'll make some references in my blogs to films, shows and books. I want people to be able to follow my references, so I'm going to try to source them, mostly, from a small body of popular material, which is noted here. Also note that I *really like* all the films, shows, and books that appear on this list (apart from maybe for Star Wars where I only really like Revenge of the Sith), and so it might be worth catching up with them if you get on with my work.   \n\n#### Films:\n\n- Star Wars Original and Prequel Trilogies\n- Harry Potter Series\n\n#### Shows: \n\n- The Walking Dead, Seasons 1-6 \n- Doctor Who (2005 version), Seasons 1-4\n- Hannibal\n\n#### Books: \n\n- Harry Potter again, although just watching the films should be enough\n- The Bible\n- The Silence of the Lambs\n"},{"title":"Visual Coding Principles","path":"visual-coding-principles","tags":["code"],"content":"This blog is the first of (possibly) a series about coding principles which _I don't see taught_, but which are _necessary to understand if you want to be a Jedi master_. \n\nI claim that mastery often involves being able to wring principles from that which others are content to leave unspoken -- as matters of intuition, or as matters of taste. So I want to use this series to try to push out the boundary of the logos, to further articulate and control. When something doesn't feel quite right -- when perhaps you shift things about and all clicks into place -- we must consider, explicitly: _What was that?_ What difference made the difference? What was God's design?\n\nAllow me before we start to pay the toll to modesty: I am not a Jedi master. I have worked as a web developer with merely intermediate skill, and there're a lot of things I don't know. Nevertheless, it is a deep compulsion within my person that draws me to these topics, and ergo I have developed my piece, which I'm sharing with you today. \n\nToday we focus on unspoken coding principles, and specifically those principles *visual*.\n\n### The Task\n\nLet's say that we're given the following task.\n\n1. Write a Javascript function `getClockTime` which returns the hours and minutes that would appear on a digital clock, which are associated with a specific `Date` instance, formatted as a string.\n2. For several different implementations of such a function, evaluate their visual-based merits and demerits, and deduce any attendant principles.\n\nTo clarify number 1., our goal is basically to re-implement:\n\n```javascript\ndate.toLocaleTimeString('en-GB', {\n  hour: '2-digit',\n  minute: '2-digit',\n});\n```\n\nwhere e.g.:\n\n```javascript\nconst date = new Date('1995-12-25T23:15:30'); // then\ngetClockTime(date); // returns 23:15\n```\n\nHopefully you get the idea. I know it's a bit of a strange example, but it's true to a project that I was working on where I didn't know that the `toLocaleTimeString` method existed, and where I recognised that I was thinking about the things which make the subject of this blog. So we're gonna go with it.\n\n### Implementation 1\n\nFirst for `getClockTime`, I offer Implementation 1:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();\n  let minutes = date.getMinutes();\n  if (hours < 10) {\n    hours = `0${hours}`;\n  }\n  if (minutes < 10) {\n    minutes = `0${minutes}`;\n  }\n  return `${hours}:${minutes}`;\n};\n```\n\nNote that all of our implementations will work in essentially this same way: we get the hours and miutes from methods on the date object; consider whether we need to prepend 0s; and then join them up with a colon. The different implementations will be interesting to us principally because they look different.\n\nHow does this first implementation look? I claim: _wrong_. I note a couple of problems, and the first is that we have violated a principle, which I call _The Principle of Line Waves_.\n\n### The Principle of Line Waves\n\nNotice the positions, which I've marked, of the ends of the lines of this function:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours(); /\n  let minutes = date.getMinutes(); /\n  if (hours < 10) { /\n    hours = `0${hours}`; /\n  } /\n  if (minutes < 10) { /\n    minutes = `0${minutes}`; /\n  } /\n  return `${hours}:${minutes}`; /\n};\n```\n\nAt a glance, you plausibly perceive as a developer that there is made out a pattern such as:\n\nThe 'Two Bumps' pattern:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();    \\\n  let minutes = date.getMinutes();  |\n  if (hours < 10) {               /\n    hours = `0${hours}`;       /\n  }                          |\n  if (minutes < 10) {         \\\n    minutes = `0${minutes}`;    \\\n  }                               |\n  return `${hours}:${minutes}`;  /\n};\n```\n\nOr the 'Comeback' Pattern:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();        /\n  let minutes = date.getMinutes();  /\n  if (hours < 10) {               /\n    hours = `0${hours}`;        /\n  }                           /\n  if (minutes < 10) {         \\\n    minutes = `0${minutes}`;    \\\n  }                               \\\n  return `${hours}:${minutes}`;     \\\n};\n```\n\nMyself, I see 'Two Bumps'.\n\nSo what's my point? I claim that both of these patterns are significant. Both of the patterns _affect_ you. (Especially if your someone for whom the function is basic enough that you have the mental space to allow the patterns to affect you; and especially if right now you're not focused on disagreeing with me.) Likely too, by the way, the affect is subconcious.\n\nWhat is the meaning of that affect? It's _something_ -- the patterns have connotations. For instance, 'Two Bumps' suggests to me that there are somehow two pushes of work in the function. There are two teams, somehow reasonably, logically grouped together, which accomplish their own piece of work. And also the continuity of the bumps suggests that the teams somehow imply one another or are complementary. This is often well-fitted to if-else statments like this example from the code for (the script for removing blogs from) this blog:\n\n```javascript\nif (!blogs.some(matchesTitle)) {                  \\\n  console.log(`\\nBlog '${title}' was not found.`); |\n  process.exit(1);                                /\n} else {                                         \\\n  writeBlogs(blogs.filter(negator(matchesTitle))); |\n  cleanupImages(title);                            /\n  console.log(`\\nBlog '${title}' removed.`);     /\n}                                              /\n;\n```\n\nThe 'Comeback' pattern on the other hand suggests to me that the function's code is somehow strong, and then settles down a bit, and then gets strong again -- like that there is something interesting/significant/involved/difficult/unique followed by less so followed by more so again. Here is an example from a separate project:\n\n```javascript\nconst setupFormSubmission = (inputNames, endpoint) => {\n  const form = getForm();\n  const handleSubmit = async (submitEvent) => {   /\n    submitEvent.preventDefault();                /\n    const formData = inputNames.reduce(         /\n      (formData, inputName) => ({              /\n        ...formData,                          /\n        [inputName]: form[inputName].value,  /\n      }),                                   /\n      {}                                   /\n    );                                     |\n    await postData(formData, endpoint);      \\\n  };                                            \\\n  form.addEventListener(\"submit\", handleSubmit);  \\\n};\n```\n\n(I have strained the applicability of the pattern slightly here for the sake of not having to make up an example.) In this case it makes sense that the-idea-that-we-are-defining-a-form-submission-handler, as well as the-attachment-of-that-handler-to-the-form would be the 'loudest' points of `setupFormSubmission`.\n\nSo what's happened here is that I have taken the patterns made out by our function's line lengths and I have inferred something about the function's operation -- that it has two pushes of work, has loud-quiet-loud logic, etc.\n\nNow I elevate this idea to a general principle. In general, the patterns formed about the ends of the lines of a function, which I call the _line waves_, (may) have connotations which impact your perception of the operation of the function. Also, that impact can be more or less accurate to the real operation of the function. When it _is_ accurate to the real operation of the function, I say that the function is _linusoidal_; and else, it's not. _The Principle of Line Waves_ is that functions should be linusoidal. By the way, you can replace function with module or class throughout.\n\nImplementation 1 is not linusoidal. I have suggested that there is a meaningful impact of its line waves. And it is an easy exercise to explain that that impact is misleading. E.g. For 'Two Bumps', I expect minimally to see correspondent two logical groupings of work. Here is one such:\n\n```javascript\nlet hours = date.getHours();    \\\nlet minutes = date.getMinutes(); |\nif (hours < 10) {              /\n  hours = `0${hours}`;      /\n}                       /\n```\n\nWhich is no such. \n\nHow do we make the function linusoidal? One simple technique is to 'break the wave' by adding newlines as below:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();     \\\n  let minutes = date.getMinutes();  \\\n\n  if (hours < 10) {       \\\n    hours = `0${hours}`;   \\\n  }                         \\\n  if (minutes < 10) {        \\\n    minutes = `0${minutes}`;  \\\n  }\n\n  return `${hours}:${minutes}`; \\\n};\n```\n\nNotice then how that instead of 'Two Bumps', or the 'Comeback', we have mainly just those two distinct slopes which suggest _bit of logic followed by separate bit of logic_, which at least is accurate and I think this makes the function look a lot better. Really. \n\nSo that is the principle of line waves and our simple way here of addressing it. But then of course that leaves still the matter of the second problem, evident with or without newlines -- since recall that I noted that there were a couple of problems with Implementation 1 -- and the second is that we have violated another principle, this time which I call _The Principle of Visual Balance_.\n\n### The Principle of Visual Balance\n\nNotice the chunkiness of this middle section for the if statements:\n\n```javascript\nif (hours < 10) {\n  hours = `0${hours}`;\n}\nif (minutes < 10) {\n  minutes = `0${minutes}`;\n}\n```\n\nIt takes up six lines. For this function, that is a fair deal of space. And thereby, it puts significant weight — I argue, too much weight — on the matter of prefixing the zeros.\n\nConsider `getClockTime`’s perspective. From its perspective, a lot of the 'important work' should’ve already been done once we had gotten the actual relevant number of hours and minutes, from the date object, for the time. To dedicate a bunch of its lines to this minor other thing, re prefixing the zeros -- it's a distortion. When I look at this function and I gauge its key operations, its key work, my attention is drawn to this overlarge middle portion. And that misrepresents the abstract story about `getClockTime`'s responsibilities.\n\nTo come at this with the help of an alternative context, one place for which similar considerations frequently arise is in the rendering logic in the return statement of a React component. \n\nFor the page that you're currently reading this on, which is written using React, the distinguishing logic resides in a component called `BlogPage`. When I was adding the ability for me to edit blogs, I added the ability also for the user to see a 'last edited' date. That made the return statement of `BlogPage` look like this:\n\n```javascript\nreturn blog ? (\n  <div className={styles.blogContainer}>\n    <article className={styles.blog}>\n      <h1 className={styles.blogTitle}>{blog.title}</h1>\n      <span className={styles.blogDate}>\n        <small>{getCalendarDate(blog.timestamp)}</small>\n        {blog.lastEdited && (\n          <small>\n            (<em>Last edited:</em> {getCalendarDate(blog.lastEdited)})\n          </small>\n        )}\n      </span>\n      <hr />\n      <main>\n        <Markdown>{blog.content}</Markdown>\n      </main>\n    </article>\n  </div>\n) : null;\n```\n\nWith that option of an additional 'last edited' date, suddenly a bunch of space in the return statment is afforded to the logic of date-gathering. At a glance, one can barely even notice the `h1` for the blog's title. And thus introduces a problem of a misdistribution of emphasis.\n\nI fixed this problem by introducing a separate component, `BlogDate`, to encapsulate the date-gathering logic, changing the return statment like so:\n\n```javascript\nreturn blog ? (\n  <div className={styles.blogContainer}>\n    <article className={styles.blog}>\n      <h1 className={styles.blogTitle}>{blog.title}</h1>\n      <BlogDate blog={blog} />\n      <hr />\n      <main>\n        <Markdown>{blog.content}</Markdown>\n      </main>\n    </article>\n  </div>\n) : null;\n```\n\nWhich is obviously much neater and reads much more sensibly. \n\nIn both of the examined cases then, what is the underlying, regulating principle? We should be able to generalise. \n\nWell, in general, the proportion of space that a piece of code occupies in its containing function (which combines line length, line number, and negative space) affects your perception of the code’s importance to that function -- of the importance of understanding that code in order that you might understand the function, and the function's responsibilities. I say that when this effect of *perceived* importance is accurate to the *true* importance, then the function is _visually balanced_; and else it’s not. _The Principle of Visual Balance_ is that functions should be visually balanced. (Again you can replace module or class.)\n\nReturning to our case of Implementation 1, I am claiming that we have violated this principle. To respect it, one thing that we can do, which is possible in Javascript, is to get rid of those braces for the if statements, reducing a hefty six lines into a more modest two:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();\n  let minutes = date.getMinutes();\n\n  if (hours < 10) hours = `0${hours}`;\n  if (minutes < 10) minutes = `0${minutes}`;\n\n  return `${hours}:${minutes}`;\n};\n```\n\nAnd since the context has changed for the line waves, I would bring this together like so to obtain:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();\n  let minutes = date.getMinutes();\n  if (hours < 10) hours = `0${hours}`;\n  if (minutes < 10) minutes = `0${minutes}`;\n  return `${hours}:${minutes}`;\n};\n```\n\nAnd, ah, that's better. Notice that the matter of prefixing the zeros is much more snappy -- `getClockTime` is more appropriately impatient with it. And we achieve (at least a greater) visual balance.\n\nAlso, note with this development that the ends of the lines of the function now form a new pattern, which is worth evaluating, and which also I supsect is quite common, and which I call the 'Reset' pattern:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();        \\\n  let minutes = date.getMinutes();       \\\n  if (hours < 10) hours = `0${hours}`;      \\\n  if (minutes < 10) minutes = `0${minutes}`;  |\n  return `${hours}:${minutes}`;              /\n};\n```\n\nThe 'Reset' pattern happens whenever you have a slope in a function's body followed by a shorter return statement. What this suggests is like that there was a chunk of work building up to the return statement, and which statement, short and blunt, was then able to draw everything together and to tie it off succintly with a bow. Moreover then this suggests to me that the function should not have any side effects, or any leakages or suchlike, because it's as if everything was cleaned up at the return. \n\nSince those suggested meanings are accurate to the context of `getClockTime`, the function remains linusoidal. And with visual balance, the two previously-noted problems are thus no more for Implemenation 1. So is that all?\n\n### Pivoting into Implementation 2\n\nInstead of simply presenting Implementation 2, I will motivate it. For the sake at least of curiosity, here are some problems that yet remain with Implementation 1, which do not have a visual basis, but which in the course of an ordinary developer's thought process may suggest that there is a better path:\n\n1. You should try to avoid reassigning variables where the reassignment so causes the meaning of the variable to become ambiguous. In our case, the hours/minutes variable holds an integer, and subsequently, confusingly, is reassigned to a string.\n2. These two lines:\n\n  ```javascript\n  if (hours < 10) hours = `0${hours}`;\n  if (minutes < 10) minutes = `0${minutes}`;\n  ```\n\n  have the same logic, and it would be nice to know -- like, OK, but to what abstraction does that logic correspond? Because that is the abstraction that `getClockTime` would preferably deal with. Contrast with the first two lines:\n\n  ```javascript\n  let hours = date.getHours();\n  let minutes = date.getMinutes();\n  ```\n\n  Here there is encapsulated some relevant logic, and `getClockTime` is just exposed this interface of `getHours` or `getMinutes`. `getClockTime` is responsible for a certain 'level of the converation', and the first two lines just set the tone. We want more appropriately to conform to it in the subsequent lines. \n3. Sometimes there is a linting rule in the codebase you're working in about if statements always having braces. In that case the implementation that we have without them would not be possible. It might seem a bit anti-climactic for me to point this out but I thought that it was worth doing so for the sake of the general point that occassionally one has to deal with annoying incidental facts like this.\n\nSo with a mind to solving all three of those problems, let us introduce Implementation 2.\n\n### Implementation 2\n\n```javascript\nconst getClockTime = (date) => {\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const clockHours = getClockDigits(hours);\n  const clockMinutes = getClockDigits(minutes);\n  return `${clockHours}:${clockMinutes}`;\n};\n\nconst getClockDigits = (time) => {\n  return `${erasable('0', time >= 10)}${time}`;\n};\n```\n\nWhat's changed here? Importantly, Implementation 2 makes use of a new function, `getClockDigits`, which does the work of the earlier if statements. I've also been a bit cheeky and I've introduced a third function, which I’m assuming that you have access to by another means, which `getClockDigits` uses, called `erasable`. Now the reason that I thought it was excusable for me to include this was because I thought it might be a good, instructive aside for me to outline the reason why I'd want to. \n\nNote that `erasable` works like this: \n\n```javascript\nconst erasable = (string, erasureCondition) => {\n  return erasureCondition ? '' : string;\n}\n```\n\nThe reason that I'd want to include it is because I think that it’s good to have little functions like this that give-you-a-name-for-the-thing and which declare your intentions. For `erasable` in particular, I also like the way that it puts emphasis on possible erasure of a substantial string, instead of say addition of an empty string. I also like the way that it gives you a visual metaphor. \n\nAnyway, we’re not super concerned about how `getClockDigits` works because we’re focused on `getClockTime`. We might be more concerned about it if we were considering visual principles at the module level. So let's consider `getClockTime`.\n\n#### Line waves and visual balance \n\nWe've identified a couple of principles already. So how does Implementation 2 square up?\n\nFor line waves, we have a slightly less pronounced 'Reset' pattern.\n\n```javascript\nconst getClockTime = (date) => {\n  const hours = date.getHours();           \\\n  const minutes = date.getMinutes();         \\\n  const clockHours = getClockDigits(hours);    \\\n  const clockMinutes = getClockDigits(minutes);  \\\n  return `${clockHours}:${clockMinutes}`;       /\n};\n```\n\nWhich is still adequate. And so the function is still linusoidal. \n\nFor visual balance, we have a similar core distribution of space. And so the function is still visually balanced. \n\n(Actually, I'd argue all the more so. Notice that, despite the fact that `getClockDigits` only, as a matter of fact, involves possibly prefixing zeros, the higher stature of the abstraction in `getClockTime` means that lines 3 and 4 have done more to earn their place.)\n\n### The Mosaic Principle\n\nNow we're going to use Implementation 2 to identify a third principle -- not from the principle's violation, but from the appearance of having conformed to it. Implementation 2 conforms to a third principle, which I call *The Mosaic Principle*. \n \nNote: This principle will be somewhat annoying to demonstrate. I have accepted certain formatting limitations for this blog, and there are issues with me choosing now to include images, and so for the matters discussed the reader will either have to use their imagination or to paste the relevant code into some editor they have on hand.\n\nHere's the background. \n\nNotice that Implementation 2 involves a predominace of variable declarations on the left hand side. On the right hand side, a predominance of function calls. Your editor will colour each of these in a consistent fashion. In my editor, the left hand side is predominantly blue, and the right a light yellowish/beige-ish colour. It looks consistent and orderly, which feels soothing and safe. Compare that to Implementation 1. The admixture of variable declarations and function calls with in this case if conditions, numeric literals, and a sprinkling more of template strings, makes for a greater disorder of colours and makes one thereby more uneasy. \n\nIt's so that Implementation 1 lies especially in accordance with a principle which I call *The Mosaic Principle*. The idea is that the colours that your editor uses to highlight your code within a function form a more or less visually pleasing mosaic. I say that when the colours _are_ visually pleasing, then the function is *mosaical*; else, it’s not. *The Mosaic Principle* is that functions should mosaical (relative to some benchmark of syntax highlighting). \n\nNow, you will notice that I am introducing this principle with a little less motivation than the others. I will say briefly that I consider it to be the lowest priority of those mentioned. Obviously one thing to note is that, since it’s probably not a good idea to standardise syntax highlighting across say your team, there is going to be some variation in the relevant colours painting a function's code between developers, and so the principle bears only or mainly upon projects undertaken by a single individual. Another thing to note is that I’ve stated the principle in terms of what’s \"visually pleasing\", but it’s unclear to me what the role of that feeling of visual pleasure is. What information am I getting from the function's mosaic? Is that useful? Misleading? Is a good mosaic proxying for something else which should more justly be the focus? I'm not entirely sure. \n\n### Pivoting into Implementation 3\n\nRegardless, we can now name three principles: of line waves, visual balance, and the mosaic principle. Now we will move on to a third implementation of `getClockTime`, which will allow us to study the principles further, and to see what else becomes of a fresh face. What cause is there to move on this time? \n\nOne thing which you might be alert to in Implementation 2 (here it is again for a reminder)\n\n```javascript \nconst getClockTime = (date) => {\n  const hours = date.getHours();           \n  const minutes = date.getMinutes();         \n  const clockHours = getClockDigits(hours);    \n  const clockMinutes = getClockDigits(minutes);  \n  return `${clockHours}:${clockMinutes}`;       \n};\n```\n\nis this repetition of \"hours\", \"minutes\", \"clockHours\", \"clockMinutes\", and especially if we were going to add seconds to that list, you might wonder simply why we were choring ourselves with so much work. And thus here is a means to get rid of it:\n\n### Implemetation 3\n\n```javascript\nconst getClockTime = (date) => {\n  const time = [date.getHours(), date.getMinutes()];\n  const clock = time.map(getClockDigits); \n  return clock.join(':');\n};\n\nconst getClockDigits = (unit) => {\n  return `${erasable('0', unit >= 10)}${unit}`;\n};\n```\n\nSo, again, we have something which works in essentially the same way, the treatment on this occasion using an array. And what of the principles?\n\n#### Line waves and visual balance and mosaicality\n\nNotice that Implementation 3 is nicely linusoidal:\n\n```javascript\nconst getClockTime = (date) => {\n  const time = [date.getHours(), date.getMinutes()]; /\n  const clock = time.map(getClockDigits);         /\n  return clock.join(':');                     /\n};\n```\n\nIt follows a 'Convergent' or 'Funnel' pattern; which in general suggests getting closer and closer to the return statement with each line building upon the previous; it suggests progressively 'separating the wheat from the chaff'; and we don’t take any sort of tangents or detours. Since that attests truly to our implementation (we get the time, and from the time we get the clock, and from the clock we get the clockTime), we have the principle of line waves. \n\nWe also apparently keep to the principle of visual balance. We have three distinguishable, coherent pieces of work, and to each their own line. So no problems there.\n\nAnd mosaic-wise, I think the function looks quite nice. All in all, valued citizen. \n\n#### Miscellaneous\n\nI want also to take this chance to make a point that, beyond general principles, sometimes there are miscellaneous, 'one-time' visual factors that come into play, and which I thought were evident in the present case. I thought that it was funny because the square brackets of an array actually look a bit like they are enclosing a real digital clock. E.g.\n\n```javascript\nconst clock = time.map(getClockDigits); // is [HH, MM]\n```\n\nSo it's worth considering that there might occassionally be something unique about the context of a function which makes one implementation visually preferrable to another.\n\n### Conclusion\n\nTrying to bring this thing to a close now, let us have a brief concluding chat. Because I figure that some of the audience are sitting very sceptical. \n\nNow, recall that I said that these principles are necessary to understand, *not* necessary to follow. For example, since I named for myself the principle of line waves, I have been able to recognise how much refactoring work I was implicitly dedicating to it, and I have been able with this greater knowledge to consider, from a more rationally-available perspective, whether or not such refactoring work is worthwhile -- and sometimes it's really not. What I'm trying to say is that if you refuse to know the principles, then it's only likely that you'll blindly be affected by them -- well, that is, presuming generously that you would have any taste about the matter in the first place. \n\nBut, that said, I'm not just putting out a warning. *Hear these principles, that you may do better to ignore them.* No. I don't consider visual principles beneath oneself. You should use them as a tool. Use them to improve your experience and your understanding as a developer. If heeding the visual aspects of your code does not significantly negatively impact some key alternative metric of your application, that is otherwise necessary to consider, such as performance, then why not?\n\nIf you’re annoyed about the prospect of having ever to think about them, if you're very concerned about wasting time and energy on the topic -- which is valid, you know, I get very concerned about that -- one suggestion is to think about the principles a lot for a concentrated period, similar to what we’re doing now, with many and different examples, and to use that period to drill those principles into your subconscious. Then for your future projects, you won't really have to think about the principles and your internal ChatGPT will integrate it all in for you.  \n\nAlso, to put some more background on the matter, it is my sense that readability, which these principles (notably the principle of line waves and of visual balance) affect, is a really big limiting factor for making stand-out, especially good web applications nowadays. I prophesy that the one who seriously innovates with his code on this frontier will change the game and will secure its riches. And let me emphasise a connotation here which readability has come to encompass: it's also about read-willingness. It's a vision of a codebase that you love, that makes sense, that feels good, that feels natural, that you want to work with; it’s a vision of happy developers. \n\nAnyway, I hope that you’ve found all this business useful. And that's my piece.\n\nSincerely,\n\nJustice\n","timestamp":1698359860534,"lastEdited":1698405495567}],"metadata":{"images":{}}}