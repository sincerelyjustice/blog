{"blogs":[{"title":"Code Masters","path":"code-masters","tags":["code"],"content":"We should have master-apprentice programmes for software engineers. *Master-apprentice programmes* are part-structured part-unstructured programmes of one-on-one guidance, discussion, and debate between a 'master' and an 'apprentice' developer. It's like pair programming, but where a lot more explicit focus is given to principles/ideas/meta-issues, rather than to the particularities of any specific task.[^1] \n\n[^1]: I think there's still a lot of low-hanging fruit re coding principles and I recently started a series about those we currently live by unspoken (see [Visual Coding Principles](/blog/visual-coding-principles)). I believe that focus on these principles is high impact, and also in general associatedly that there is also overvalued among developers incidental knowledge about particular technologies. \n\nWhat would such a programme accomplish? Mainly, it would accomplish the creation of more code masters. A code master is a maturation of the idea of a 10x developer. Code masters produce a much greater output than ordinary developers, and also, they do so at a greater quality. That means that they count for many such developers, and in some ways for more than any number of them. A code master is an artist whose abilites inspire awe among the non-masters.\n\nWhy do master-apprentice programmes work? Several reasons:[^2]\n\n[^2]: Some stipulations are implicit herein in the matter of the master choosing their apprentice wisely and vice versa.\n\n- The ability for the master to study the apprentice and to recognise patterns in their mistakes. This enables the master to share especially high-leverage, tailored insights. \n- The ability for an apprentice to be insistently curious, to keep asking why questions, and for the master to follow their individual train of thought. \n- The formation of bonds of trust. The apprentice and master can grow to trust one another, and therefore feel safe to share radical or otherwise-fraught ideas. \n- The intimacy of comparison between the apprentice and the master. The comparison between apprentice and master can foster a competitve, aspirational instinct in the apprentice (which can be extremely powerful); and in the master, it can foster his desire to prove himself a master, and thus to make his premises more robust (which can also be extremely powerful). \n\nNote that my sense is that code masters in our world are very rare. Part of that is because they don't take on apprentices. If as a rule a master takes on two apprentices, and raises them to mastery, let's say over the course of a few years, then we would soon have a lot more masters in the world. However, since masters are so rare, we should begin our master-apprentice programmes more imperfectly -- between what we more comfortably refer to as simply 'senior' and 'junior' developers. The environment of much idea-sharing should occasionally mean that therby are produced true code masters. Those masters can then gradually be introduced as the more predominant leaders of the programmes. And once there are a lot of masters, perhaps we can also be less shy about identifying them. \n\n\n\n","timestamp":1698672032969},{"title":"Code Directors","path":"code-directors","tags":["code"],"content":"A code director is akin to a movie director. He oversees a codebase, and he calls the shots. Here's a summary of his role.\n\n- He 'owns' the codebase. It's 'his'.\n- He answers to the overall quality of the codebase. If something's gone rotten, he is responsible.\n- He reviews all inputs. E.g. he reviews every ticket.\n- He reviews all outputs. E.g. he reviews every pull request.\n- He inputs. Given an understanding of the needs of the codebase, the business trusts him to create and to allocate work.\n- He outputs. He contributes to the codebase.\n\n### Why Code Directors?\n\nWhat's that all for? Why would we want a code director? \n\nI'll build up to it.\n\n#### Background\n\nWithin a team, collective decision-making is hard. A collective lacks conviction. Often, decisions don't get made, and even discussions about an issue are avoided. If decisions do get made, often an irrational process had to intervene such as voting. So the team fails to make much progress. In order to make progress, the team recognises that it must develop some means of individualising decision-making in the majority of cases.\n\nThe prevalent means by which this is done in a software development context is by dividing up responsibilities amongst the team and by giving team members decision-making power over their own individual components e.g. over their own tickets. They form a so-called 'agile team'.\n\n#### Problems\n\nI suggest that there are some problems with the existing model of an agile team. And that at the prompting of which we should upgrade the agile team to a *directed agile team*, by adding a code director role. \n\nConsider a couple of facts:\n\n1. By giving everyone decision-making power, everyone, somewhere, makes their own decisions about the code, and their own standards apply.[^1]\n\n2. By dividing out responsibilities, no one is responsible for the codebase entire.\n\n[^1]: There are a vast many subtleties about the way people code which are impossible to normalise automatically and may yet lack any kind of recognition in language.\n\nWhence we have the following problems:\n\n1. From Fact (1), since decisions, as a matter of their composing principles, will vary between developers, this will lead to a measure of incoherence, inconsistency and general confusion across the codebase.\n\n2. From Fact (2), developers who are not responsible for the entire codebase will often focus on climbing their own local optimum at the expense of the global one. I.e., they will be biased in favour of one metric, which is relevant to their work, over some ignored other.\n\n3. From Fact (1) and Fact (2): If a lower-skill developer has decision-making power, and no other developer has the ownership sufficient to bother overruling their work, lower-standard decisions can enter into canon.\n\nNow, having a code director partially undermines Fact (1), and undermines Fact (2) by definition, so let's think about the positive impact of introducing a code director re solving these problems.\n\nFor Problem (1), we get a partial solution in that everything must pass through the code directors mind: there is a single party, the director, that is always present at least to review every piece of work. We have a consistent normalising factor which is the scrutiny of whatever the director's standards are. His ways of working are the effective default. We're still assuming that the brainpower of a group effort is necessary, so since the director is plausibly not completely reinventing each developer's work upon submission, some inconsistent standards will still slip through. But this provides us with a new defence.\n\nFor Problem (2), we theoretically get a complete solution, assuming that the code director does his job. There is pressure on him to consider the state of the codebase as a whole. So it will not do for him to be disrespecting metrics that happen to be out-of-focus for some specific piece of work.\n\nFor Problem (3), we get somewhat of a soution in that the code director has to answer for any bad code that gets through him. He has an incentive to do throughgoing quality control. And also since the code director should generally be the best developer in a team, there should be applied thereby the best quality control that the team could muster.\n\nSo having a code director would help solve some important problems with existing agile teams. \n\n#### More accounting\n\nTo solve problems (1)-(3), I used the fact that the code director owns and is responsible for the codebase, and the fact that he reviews all outputs. But what of the other named aspects of his role? \n\nAll should considered complementary to this core idea of 'ownership'. Let's briefly expand upon each. \n\n- *He reviews all inputs. E.g. he reviews every ticket.*\n\nThe code director is basically the Product Owner's go-to man. Why? Because he understands the codebase the best; he's best able to represent the interests of developers; and he understands what's possible and practical for the team. \n\n- *He inputs. Given an understanding of the needs of the codebase, the business trusts him to create and to allocate work.*\n\nAgain this is an expectation following that the code director understands the codebase the best. E.g. he will know when it's appropriate to clear certain technical debt. \n\n- *He outputs. He contributes to the codebase.*\n\nWhen the code director does things himself, he finds out a lot through trial and error about what works for the code and what doesn't, and that can save him from \"Can't we just ...\"s when evaluating other people's work. Also, evidence of the code director's skillful contributions can help teammates view him as more of a leader since he \"models advancement of the cause\" (see my [blog](/blog/leadership) on leadership). They at least can respect him more and might be less bristly about his offering opinions. \n\n### Successful Code Directors\n\nI'll list a few things generically required for a code director to be successful:\n\n- A code director should a code master (see my [blog](/blog/code-masters) re code masters). That means he should be a very knowledgable and competent developer. If he's not, he can become a big bottleneck for (good) work getting through to production. \n\n- A code director should be a good communicator. This is so his teammates want to work with him, can come to believe in his principles, and so that the work they do is done with care in consequence.\n\n- A code director should not be easily cowed. He should be intolerant of *bad product*. He should always enforce his high standards, not allowing himself to get pressured into something inadequate.\n\n- A code director should be prepared for long-term commitment to a codebase! \n\n### A Transitonal Mode\n\nI'm going to wrap things up now. Here's a closing thought. For modern software development, on large-scale projects, a directed agile team is in my mind the proper next increment moving on from an agile team. But that isn't my final vision for the future. I think of the code director as a prelude to the developer who leads even large-scale projects completely on his lonesome! -- a single code master with formiddable mind, who uses some AI buddy to account for incidental knowledge. Developer and AI like Jedi and droid. This one-developer approach is part of my other vision of raising more code masters through master-apprentice programmes (again see my recent [blog](/blog/code-masters) about this).\n","timestamp":1698779140042},{"title":"Visual Coding Principles","path":"visual-coding-principles","tags":["code"],"content":"When I write code, I want it to look good. Below I'll outline some principles to consider for writing good-looking code.   \n\n### Task\n\nSuppose we are tasked to re-implement\n\n```javascript\ndate.toLocaleTimeString('en-GB', {\n  hour: '2-digit',\n  minute: '2-digit',\n});\n```\nin javascript in a function `getClockTime`, which in particular returns, as a string, the hours and minutes that would appear on a digital clock, associated with a specific `Date` instance. E.g.\n\n```javascript\nconst date = new Date('1995-12-25T23:15:30'); // then\ngetClockTime(date); // returns 23:15\n```\n\n### Implementation 1\n\nHere is one way to accomplish this:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();\n  let minutes = date.getMinutes();\n  if (hours < 10) {\n    hours = `0${hours}`;\n  }\n  if (minutes < 10) {\n    minutes = `0${minutes}`;\n  }\n  return `${hours}:${minutes}`;\n};\n```\n\nI claim that this function looks wrong. \n\n### Line Waves\n\nNotice the positions of the ends of the lines of this function:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours(); /\n  let minutes = date.getMinutes(); /\n  if (hours < 10) { /\n    hours = `0${hours}`; /\n  } /\n  if (minutes < 10) { /\n    minutes = `0${minutes}`; /\n  } /\n  return `${hours}:${minutes}`; /\n};\n```\n\nAt a glance, one perceives that there is made out a pattern such as:\n\na 'two bumps' pattern:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();    \\\n  let minutes = date.getMinutes();  |\n  if (hours < 10) {               /\n    hours = `0${hours}`;       /\n  }                          |\n  if (minutes < 10) {         \\\n    minutes = `0${minutes}`;    \\\n  }                               |\n  return `${hours}:${minutes}`;  /\n};\n```\n\nor a 'comeback' pattern:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();        /\n  let minutes = date.getMinutes();  /\n  if (hours < 10) {               /\n    hours = `0${hours}`;        /\n  }                           /\n  if (minutes < 10) {         \\\n    minutes = `0${minutes}`;    \\\n  }                               \\\n  return `${hours}:${minutes}`;     \\\n};\n```\n\nBoth of these example patterns have naive connotations. \n\nE.g. 'two bumps' suggests to me that there are somehow two pushes/teams of work in the function. This is often well-fitted to if-else statments like this example from the code for (the script for removing blogs from) this blog:\n\n```javascript\nif (!blogs.some(matchesTitle)) {                  \\\n  console.log(`\\nBlog '${title}' was not found.`); |\n  process.exit(1);                                /\n} else {                                         \\\n  writeBlogs(blogs.filter(negator(matchesTitle))); |\n  cleanupImages(title);                            /\n  console.log(`\\nBlog '${title}' removed.`);     /\n}                                              /\n;\n```\n\nThen also e.g. the 'comeback' pattern suggests to me that the function's code is somehow strong, then settles down, and then gets strong again -- something interesting/significant/involved/difficult/unique followed by less so followed by more so again. Consider this example from a separate project:\n\n```javascript\nconst setupFormSubmission = (inputNames, endpoint) => {\n  const form = getForm();\n  const handleSubmit = async (submitEvent) => {   /\n    submitEvent.preventDefault();                /\n    const formData = inputNames.reduce(         /\n      (formData, inputName) => ({              /\n        ...formData,                          /\n        [inputName]: form[inputName].value,  /\n      }),                                   /\n      {}                                   /\n    );                                     |\n    await postData(formData, endpoint);      \\\n  };                                            \\\n  form.addEventListener(\"submit\", handleSubmit);  \\\n};\n```\n\n(I have strained the applicability of the pattern here for the sake of not having to make something up.) In this case, it makes sense that the-idea-that-we-are-defining-a-form-submission-handler, as well as the-attachment-of-that-handler-to-the-form, would be the 'loudest'/'strongest' points of `setupFormSubmission`.\n\nI make my point in general: \n\nThe patterns formed about the ends of the lines of a function, the _line waves_, (may) have connotations which impact one's perception of the operation of the function. That impact can be more or less accurate to the real operation of the function. \n\nIf it _is_ accurate, I say the function is _linusoidal_; else, it's not. The first principle I name is that functions should be linusoidal. You can also replace function with module or class throughout.\n\nImplementation 1 of `getClockTime` looks bad in part because it is not linusoidal. E.g. For 'two bumps', I expect to see two correspondent logical groupings of work. Here is one such:\n\n```javascript\nlet hours = date.getHours();    \\\nlet minutes = date.getMinutes(); |\nif (hours < 10) {              /\n  hours = `0${hours}`;      /\n}                       /\n```\n\nWhich is no such. \n\n### Line waves trick\n\nOne simple technique to make a function linusoidal can be to 'break the wave' by adding newlines like:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();     \\\n  let minutes = date.getMinutes();  \\\n\n  if (hours < 10) {       \\\n    hours = `0${hours}`;   \\\n  }                         \\\n  if (minutes < 10) {        \\\n    minutes = `0${minutes}`;  \\\n  }\n\n  return `${hours}:${minutes}`; \\\n};\n```\n\nHere, now, separate pieces of logic are grouped with their own coherent wave. The function looks better but it still looks bad. \n\n### Visual Balance\n\nNotice the chunkiness of this middle section for the if statements:\n\n```javascript\nif (hours < 10) {\n  hours = `0${hours}`;\n}\nif (minutes < 10) {\n  minutes = `0${minutes}`;\n}\n```\n\nIt takes up six lines. For this function, that is a lot of space. Thereby, it puts too much weight on the matter of prefixing the zeros.\n\nFrom `getClockTime`’s perspective, a lot of the important work should’ve already been done after getting the relevant number of hours and minutes from the date object for the time. To dedicate many of its lines to a minor other matter, re prefixing the zeros, creates a distortion. When I look at the function and gauge its key operations, my attention is drawn to the overlarge middle portion, and that distorts the abstract story about `getClockTime`'s responsibilities.\n\nCompare with another example. For the page you're currently reading this on, written in React, the distinguishing logic resides in a component called `BlogPage`. When I was adding the ability for me to edit blogs, I added the ability also for the user to see a 'last edited' date. That made the return statement of `BlogPage` look like this:\n\n```javascript\nreturn blog ? (\n  <div className={styles.blogContainer}>\n    <article className={styles.blog}>\n      <h1 className={styles.blogTitle}>{blog.title}</h1>\n      <span className={styles.blogDate}>\n        <small>{getCalendarDate(blog.timestamp)}</small>\n        {blog.lastEdited && (\n          <small>\n            (<em>Last edited:</em> {getCalendarDate(blog.lastEdited)})\n          </small>\n        )}\n      </span>\n      <hr />\n      <main>\n        <Markdown>{blog.content}</Markdown>\n      </main>\n    </article>\n  </div>\n) : null;\n```\n\nThence lots of space in the return statment was afforded to the logic of date-gathering, thence misplacing emphasis; at a glance, one barely even notices the `h1` for the blog's title. \n\nI fixed this problem by introducing a separate component, `BlogDate`, to encapsulate the date-gathering logic, changing the return statment like so:\n\n```javascript\nreturn blog ? (\n  <div className={styles.blogContainer}>\n    <article className={styles.blog}>\n      <h1 className={styles.blogTitle}>{blog.title}</h1>\n      <BlogDate blog={blog} />\n      <hr />\n      <main>\n        <Markdown>{blog.content}</Markdown>\n      </main>\n    </article>\n  </div>\n) : null;\n``` \n\nAgain I infer to the general idea: \n\nThe proportion of space that a piece of code occupies in its containing function (which combines line length, line number, and negative space) affects your perception of the code’s importance to that function. 'Visual balance' is about matching this perceived importance to the true importance. Stated as a principle, functions should be visually balanced. (Still fine to replace for module or class.)\n\nImplementation 1 is not visually balanced because prefixing the 0s takes up too much space. \n\n### Establishing visual balance\n\nI suggest establishing visual balance by eliminating the braces about the if statements. Whence six lines become two:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();\n  let minutes = date.getMinutes();\n\n  if (hours < 10) hours = `0${hours}`;\n  if (minutes < 10) minutes = `0${minutes}`;\n\n  return `${hours}:${minutes}`;\n};\n```\n\nAnd since the context has changed for the line waves, I would bring this together to obtain:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();\n  let minutes = date.getMinutes();\n  if (hours < 10) hours = `0${hours}`;\n  if (minutes < 10) minutes = `0${minutes}`;\n  return `${hours}:${minutes}`;\n};\n```\n\nAnd that looks better. The matter of prefixing the zeros is more snappy -- `getClockTime` is more appropriately impatient with it. Also, the ends of the lines of the function now form a common pattern I call the 'reset' wave:\n\n```javascript\nconst getClockTime = (date) => {\n  let hours = date.getHours();        \\\n  let minutes = date.getMinutes();       \\\n  if (hours < 10) hours = `0${hours}`;      \\\n  if (minutes < 10) minutes = `0${minutes}`;  |\n  return `${hours}:${minutes}`;              /\n};\n```\n\nThis wave happens whenever you have a slope in a function's body followed by a shorter return statement. Naively, this suggests that there was a chunk of work building up to the return statement, and which statement  was then able to succictly draw things together and tie them off. More, it suggests that the function is *done*, and therefore that it should not have any side effects, leakages, suchlike. Those suggested meanings are accurate to `getClockTime`. Therefore it is now linusoidal and visually balanced. \n\nBut we can do better. \n\n### Some problems\n\nLet me point out some ordinary problems with the first idea for `getClockTime`, which we'll use to pivot into another, and then I'll assess and compare this second implementation for any more visual merits/demerits. \n\nProblems:\n\n1. You should try to avoid reassigning variables where the reassignment causes the meaning of the variable to become ambiguous. In our case, the hours/minutes variable holds an integer, and subsequently, confusingly, is reassigned to a string.\n2. These two lines:\n\n    ```javascript\n    if (hours < 10) hours = `0${hours}`;\n    if (minutes < 10) minutes = `0${minutes}`;\n    ```\n\n    have the same logic, and it would be nice to know to what abstraction that logic corresponds -- which is the abstraction that `getClockTime` preferably deals with. Contrast with the first two lines:\n\n    ```javascript\n    let hours = date.getHours();\n    let minutes = date.getMinutes();\n    ```\n\n    Here there is encapsulated some relevant logic, and `getClockTime` is exposed merely to the interface of `getHours` or `getMinutes`. `getClockTime` is responsible for a certain 'level of the converation', and the first two lines set a tone which we want to conform to more appropriately in subsequent lines. \n  \n3. Sometimes there is a linting rule in a codebase about if statements always having braces. Occassionally one has to deal with annoying incidental facts like this.\n\n### Implementation 2\n\nWith a mind to solving all three of those problems, here is an alternative:\n\n```javascript\nconst getClockTime = (date) => {\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const clockHours = getClockDigits(hours);\n  const clockMinutes = getClockDigits(minutes);\n  return `${clockHours}:${clockMinutes}`;\n};\n\nconst getClockDigits = (time) => {\n  return `${erasable('0', time >= 10)}${time}`;\n};\n```\n\nImplementation 2 makes use of a new function, `getClockDigits`, which does the work of the earlier if statements. I've also snuck in a third function, which `getClockDigits` uses, called `erasable`[^1] -- though we’re not concerned about how `getClockDigits` works, because we’re focused on `getClockTime`. We may be more concerned if we were considering visual principles at the module level. \n\n[^1]: The reason that I thought it was excusable for me to include this was because I thought it might be a good, instructive aside for me to outline the reason why I'd want to. \n\n    Note that `erasable` works like this: \n\n    ```javascript\n    const erasable = (string, erasureCondition) => {\n      return erasureCondition ? '' : string;\n    }\n    ```\n\n    The reason that I'd want to include it is because I like to have small functions like this (ideally sourced from a library of similar such functions) that give-you-a-name-for-the-thing and which declare your intentions. For `erasable` in particular, I also like the way that it puts emphasis on possible erasure of a substantial string, instead of say addition of an empty string. I also like the visual metaphor. \n\n\n#### Visual assesment\n\nFor line waves, Implementation 2 follows a similar 'reset' pattern:\n\n```javascript\nconst getClockTime = (date) => {\n  const hours = date.getHours();           \\\n  const minutes = date.getMinutes();         \\\n  const clockHours = getClockDigits(hours);    \\\n  const clockMinutes = getClockDigits(minutes);  \\\n  return `${clockHours}:${clockMinutes}`;       /\n};\n```\n\nFor visual balance, we have a similar core distribution of space. However this implementation has a slightly superior visual balance since, despite the fact that `getClockDigits` only, as a matter of fact, involves possibly prefixing zeros, the higher stature of the abstraction now featuring in `getClockTime` means that lines 3 and 4 have done more to earn their place.\n\nThere is also something else which appeals to me visually about this implementation, which is that it forms a pleasing 'mosaic'.\n\n### The mosaic principle\n\nNotice that Implementation 2 involves a predominace of variable declarations on the left hand side. On the right hand side, a predominance of function calls. \n\nThis looks consistent and orderly and feels soothing. To the effect is added that one's editor will colour each of these (variable declarations/function calls) in a uniform fashion. In my editor, the left hand side is predominantly blue, and the right a light yellowish/beige-ish colour. \n\nCompare that to Implementation 1. The admixture of variable declarations and function calls with, in this case, if conditions, numeric literals, and a sprinkling more of template strings, makes for a greater disorder of shapes and colours and makes one thereby more uneasy. \n\nTherefore I say that the second implementation of `getClockTime` forms a more visually pleasing mosaic, which refers in summary to the way that the shapes and colours of a function fit together. Implementation 2 is *mosaical*, and as a princple functions should (relative to some benchmark of syntax highlighting) be mosaical.  \n\n### Some more problems\n\nI want to introduce a third implementation for `getClockTime` for the sake of more assessment and comparison. One problem still with Implementation 2 which might motivate this is the repetition of \"hours\", \"minutes\", \"clockHours\", \"clockMinutes\". Especially if we were going to add seconds (or more) to that list, this begs the question of whether it is more efficient to loop the work. \n\n### Implemetation 3\n\nHere is how we could do that:\n\n```javascript\nconst getClockTime = (date) => {\n  const time = [date.getHours(), date.getMinutes()];\n  const clock = time.map(getClockDigits); \n  return clock.join(':');\n};\n\nconst getClockDigits = (unit) => {\n  return `${erasable('0', unit >= 10)}${unit}`;\n};\n```\n\n#### Visual assesment\n\nConsidering Implementation 3's line waves:\n\n```javascript\nconst getClockTime = (date) => {\n  const time = [date.getHours(), date.getMinutes()]; /\n  const clock = time.map(getClockDigits);         /\n  return clock.join(':');                     /\n};\n```\n\nIt follows a 'convergent' or 'funnel' wave pattern, which suggests getting closer to the return statement with each line, each building upon the previous; it suggests progressively 'separating the wheat from the chaff', and where we don’t take any sort of tangents or detours. That attests truly to our implementation (we get the time, and from the time we get the clock, and from the clock we get the clockTime), so the function is linusoidal.\n\nWe also keep to the principle of visual balance. We have three distinguishable, coherent pieces of work, and to each their own line. \n\nMosaically, I think the introduction of the array makes the function look more jagged and disorderly. However the colours are generally concordant. \n\nAnd on a miscellaneous note about the array, it does actually look a little bit like a real digital clock. \n","timestamp":1698359860534,"lastEdited":1718471551347},{"title":"Leadership","path":"leadership","tags":["psychology","sociology"],"content":"In a group of people with common cause, the **leader** of the group has four key responsibilities:\n\n1. **He models the advancement of the cause.** \n\nThe leader makes it seem like advancing the cause is real, possible, and imitable, by virtue of his own contribution. \n\n2. **He reminds people of the worthiness of the cause.** \n\nThe leader makes the cause seem worthwhile and compelling, through his words and actions. \n\n3. **He organises people.**\n\nThe leader helps group members find their roles and incorporates them into a broader vision.\n\n4. **He makes group decisions.**\n\nThe leader assumes some ability to make decisions on behalf of the group, and to speak for them, as an adequate representative of their cause. \n\n\n","timestamp":1698755236334,"lastEdited":1718470241429},{"title":"Need & Excuse","path":"need-excuse","tags":["psychology"],"content":"One of the most common patterns of irrationality in our world comes from the combination of a need and an excuse: a need and an excuse not to be rational. \n\nYou start with the need; and all needs have an anxious quality to them; and the need is like a hunger and it tells you to *go foraging*. So you're up. You're awake. And you're searching -- but for what? -- for an excuse. Because given the need you have also the idea that there is a kind of debt that you have to pay -- a debt to the Symbolic, to the Word -- before you can take some concrete course of action; you need a *reason*. But the reason you give -- your notion of the debt to remediate -- it's distorted, corrupted, by the strength of the need; and from which your excuse. \n\nWhile the need is around, the anxiety is around; while the anxiety is around, you will want to relieve it; and people take desperate measures, people slight the God of Reason in his own proper domain, in order to do so. \n\nIt's a simple pattern, you see, but it's worth saying out loud.\n\nPrompt an AI if you need examples to catch on. \n","timestamp":1704221728923},{"title":"Summary of (Cholestasis in) Toxic Bile Theory","path":"summary-toxic-bile-theory","tags":["health","biology"],"content":"*acknowledgement: influenced by Dr Garret Smith*\n\neverything that you ingest and absorb through your intestines passes through your liver before reaching the rest of your body. some of what you ingest is poison. the liver accumulates this poison to stop it from reaching the rest of the body. its goal is to put the poison back into the intestines with the hope that it will leave for good via the faeces. the liver puts the poison (or a transformation thereof) back into the intestines via a substance called bile—and generally about 5% of this poison-containing bile does get excreted. \n\nhowever, if you consume enough poison over time, not enough of the poison leaves the body via the bile; and in particular, since 95% of the bile is recycled, to which new poison keeps getting added, the poison in the bile starts to concentrate. \n\nonce you have concentrated, extra-poisonous bile, the bile causes damage to the ducts it’s supposed to pass through from liver to intensines, and this causes a build up of debris, and this leads to cholestasis, meaning impaired bile flow. Cholestasis causes bile to be stuck in place under pressure. This causes the bile to burst out into the bloodstream. \n\ntherefore, once you’ve consumed enough poison over time, this leads to cholestasis and causes the defence of the liver to collapse. the poison has breached the city walls. then depending on where the poison ends up in the body (delivered via the bloodstream), moreover it starts earning its title there: it wreaks _poison_: damage, mutation, antagonism, etc. \n\nYour body hasn’t given up: it will do everything it can to excrete this poison through the urine, the skin, the sweat, mucus, saliva, your breath, your tears and your ears. If it’s fat soluble it’ll try to imprison it in fat. If it can be metabolised away we will try to metabolise it. And if we can shield it or contain it or mitigate its effects with any compound or protein we'll do all that too. \n\nThe body has secondary defences but note in general that none of these are preferred. And therefore as we come to rely on these defences, all sorts of _problems_ begin to present themselves. \n\nThat is, a chronic poisoning results in a chronic disease.","timestamp":1711199178318,"lastEdited":1713294712903}],"metadata":{"images":{}}}